import * as ts from "typescript";
import { CompilerOptions, LuaTarget } from "./CompilerOptions";
import * as tstl from "./LuaAST";
import { LuaLibFeature } from "./LuaLib";
export declare type StatementVisitResult = tstl.Statement | tstl.Statement[] | undefined;
export declare type ExpressionVisitResult = tstl.Expression;
export declare enum ScopeType {
    File = 1,
    Function = 2,
    Switch = 4,
    Loop = 8,
    Conditional = 16,
    Block = 32,
    Try = 64,
    Catch = 128
}
interface SymbolInfo {
    symbol: ts.Symbol;
    firstSeenAtPos: number;
}
interface FunctionDefinitionInfo {
    referencedSymbols: Map<tstl.SymbolId, ts.Node[]>;
    definition?: tstl.VariableDeclarationStatement | tstl.AssignmentStatement;
}
interface Scope {
    type: ScopeType;
    id: number;
    referencedSymbols?: Map<tstl.SymbolId, ts.Node[]>;
    variableDeclarations?: tstl.VariableDeclarationStatement[];
    functionDefinitions?: Map<tstl.SymbolId, FunctionDefinitionInfo>;
    importStatements?: tstl.Statement[];
    loopContinued?: boolean;
    functionReturned?: boolean;
}
export interface EmitResolver {
    isValueAliasDeclaration(node: ts.Node): boolean;
    isReferencedAliasDeclaration(node: ts.Node, checkChildren?: boolean): boolean;
    isTopLevelValueImportEqualsWithEntityName(node: ts.ImportEqualsDeclaration): boolean;
    moduleExportsSomeValue(moduleReferenceExpression: ts.Expression): boolean;
}
export interface DiagnosticsProducingTypeChecker extends ts.TypeChecker {
    getEmitResolver(sourceFile?: ts.SourceFile, cancellationToken?: ts.CancellationToken): EmitResolver;
}
export declare class LuaTransformer {
    protected program: ts.Program;
    protected readonly typeValidationCache: Map<ts.Type, Set<ts.Type>>;
    protected currentNamespace?: ts.ModuleDeclaration;
    protected checker: DiagnosticsProducingTypeChecker;
    protected options: CompilerOptions;
    protected luaTarget: LuaTarget;
    protected isStrict: boolean;
    constructor(program: ts.Program);
    protected genVarCounter: number;
    protected luaLibFeatureSet: Set<LuaLibFeature>;
    protected visitedExportEquals: boolean;
    protected scopeStack: Scope[];
    protected classStack: ts.ClassLikeDeclaration[];
    protected symbolInfo: Map<tstl.SymbolId, SymbolInfo>;
    protected symbolIds: Map<ts.Symbol, tstl.SymbolId>;
    protected genSymbolIdCounter: number;
    private setupState;
    protected currentSourceFile: ts.SourceFile;
    protected isModule: boolean;
    protected resolver: EmitResolver;
    transformSourceFile(sourceFile: ts.SourceFile): tstl.Block;
    transformStatement(node: ts.Statement): StatementVisitResult;
    /** Converts an array of ts.Statements into an array of tstl.Statements */
    protected transformStatements(statements: readonly ts.Statement[]): tstl.Statement[];
    transformBlock(block: ts.Block): tstl.Block;
    transformBlockAsDoStatement(block: ts.Block): StatementVisitResult;
    transformExportAssignment(statement: ts.ExportAssignment): StatementVisitResult;
    transformExportDeclaration(statement: ts.ExportDeclaration): StatementVisitResult;
    protected transformExportSpecifier(node: ts.ExportSpecifier): tstl.AssignmentStatement;
    protected transformExportSpecifiersFrom(statement: ts.ExportDeclaration, moduleSpecifier: ts.Expression, exportSpecifiers: ts.ExportSpecifier[]): tstl.Statement;
    protected transformExportAllFrom(statement: ts.ExportDeclaration): tstl.Statement | undefined;
    transformImportDeclaration(statement: ts.ImportDeclaration): StatementVisitResult;
    protected transformImportSpecifier(importSpecifier: ts.ImportSpecifier, moduleTableName: tstl.Identifier): tstl.VariableDeclarationStatement;
    protected createModuleRequire(moduleSpecifier: ts.StringLiteral, resolveModule?: boolean): tstl.CallExpression;
    protected validateClassElement(element: ts.ClassElement): void;
    transformImportEqualsDeclaration(declaration: ts.ImportEqualsDeclaration): StatementVisitResult;
    transformExternalModuleReference(externalModuleReference: ts.ExternalModuleReference): ExpressionVisitResult;
    protected transformEntityName(entityName: ts.EntityName): ExpressionVisitResult;
    transformQualifiedName(qualifiedName: ts.QualifiedName): ExpressionVisitResult;
    transformClassDeclaration(statement: ts.ClassLikeDeclaration, nameOverride?: tstl.Identifier): StatementVisitResult;
    protected createClassCreationMethods(statement: ts.ClassLikeDeclarationBase, className: tstl.Identifier, localClassName: tstl.Identifier, classNameText: string, extendsType?: ts.Type): tstl.Statement[];
    protected transformClassInstanceFields(classDeclaration: ts.ClassLikeDeclaration, instanceFields: ts.PropertyDeclaration[]): tstl.Statement[];
    protected createConstructorName(className: tstl.Identifier): tstl.TableIndexExpression;
    protected transformConstructorDeclaration(statement: ts.ConstructorDeclaration, className: tstl.Identifier, instanceFields: ts.PropertyDeclaration[], classDeclaration: ts.ClassLikeDeclaration): StatementVisitResult;
    transformGetAccessorDeclaration(getAccessor: ts.GetAccessorDeclaration, className: tstl.Identifier): StatementVisitResult;
    transformSetAccessorDeclaration(setAccessor: ts.SetAccessorDeclaration, className: tstl.Identifier): StatementVisitResult;
    transformMethodDeclaration(node: ts.MethodDeclaration, className: tstl.Identifier, noPrototype: boolean): StatementVisitResult;
    protected transformParameters(parameters: ts.NodeArray<ts.ParameterDeclaration>, context?: tstl.Identifier): [tstl.Identifier[], tstl.DotsLiteral | undefined, tstl.Identifier | undefined];
    protected isRestParameterReferenced(identifier: tstl.Identifier, scope: Scope): boolean;
    protected transformFunctionBody(parameters: ts.NodeArray<ts.ParameterDeclaration>, body: ts.Block, spreadIdentifier?: tstl.Identifier): [tstl.Statement[], Scope];
    protected transformParameterDefaultValueDeclaration(parameterName: tstl.Identifier, value?: ts.Expression, tsOriginal?: ts.Node): tstl.Statement;
    transformBindingPattern(pattern: ts.BindingPattern, table: tstl.Identifier, propertyAccessStack?: ts.PropertyName[]): StatementVisitResult;
    protected createModuleLocalNameIdentifier(declaration: ts.ModuleDeclaration): tstl.Identifier;
    transformModuleDeclaration(statement: ts.ModuleDeclaration): StatementVisitResult;
    transformEnumDeclaration(enumDeclaration: ts.EnumDeclaration): StatementVisitResult;
    protected computeEnumMembers(node: ts.EnumDeclaration): Array<{
        name: ts.PropertyName;
        value: tstl.Expression;
        original: ts.Node;
    }>;
    protected transformGeneratorFunction(parameters: ts.NodeArray<ts.ParameterDeclaration>, body: ts.Block, spreadIdentifier?: tstl.Identifier): [tstl.Statement[], Scope];
    transformFunctionDeclaration(functionDeclaration: ts.FunctionDeclaration): StatementVisitResult;
    transformTypeAliasDeclaration(_statement: ts.TypeAliasDeclaration): StatementVisitResult;
    transformInterfaceDeclaration(_statement: ts.InterfaceDeclaration): StatementVisitResult;
    transformVariableDeclaration(statement: ts.VariableDeclaration): StatementVisitResult;
    transformVariableStatement(statement: ts.VariableStatement): StatementVisitResult;
    transformExpressionStatement(statement: ts.ExpressionStatement | ts.Expression): StatementVisitResult;
    transformYieldExpression(expression: ts.YieldExpression): ExpressionVisitResult;
    transformReturnStatement(statement: ts.ReturnStatement): StatementVisitResult;
    transformIfStatement(statement: ts.IfStatement): StatementVisitResult;
    transformWhileStatement(statement: ts.WhileStatement): StatementVisitResult;
    transformDoStatement(statement: ts.DoStatement): StatementVisitResult;
    transformForStatement(statement: ts.ForStatement): StatementVisitResult;
    protected transformForOfInitializer(initializer: ts.ForInitializer, expression: tstl.Expression): tstl.Statement | undefined;
    protected transformLoopBody(loop: ts.WhileStatement | ts.DoStatement | ts.ForStatement | ts.ForOfStatement | ts.ForInOrOfStatement): tstl.Statement[];
    protected transformBlockOrStatement(statement: ts.Statement): tstl.Statement[];
    protected transformForOfArrayStatement(statement: ts.ForOfStatement, block: tstl.Block): StatementVisitResult;
    protected transformForOfLuaIteratorStatement(statement: ts.ForOfStatement, block: tstl.Block): StatementVisitResult;
    protected transformForOfIteratorStatement(statement: ts.ForOfStatement, block: tstl.Block): StatementVisitResult;
    protected transformForRangeStatement(statement: ts.ForOfStatement, body: tstl.Block): StatementVisitResult;
    transformForOfStatement(statement: ts.ForOfStatement): StatementVisitResult;
    transformForInStatement(statement: ts.ForInStatement): StatementVisitResult;
    transformSwitchStatement(statement: ts.SwitchStatement): StatementVisitResult;
    transformBreakStatement(breakStatement: ts.BreakStatement): StatementVisitResult;
    protected transformScopeBlock(block: ts.Block, scopeType: ScopeType): [tstl.Block, Scope];
    transformTryStatement(statement: ts.TryStatement): StatementVisitResult;
    transformThrowStatement(statement: ts.ThrowStatement): StatementVisitResult;
    transformContinueStatement(statement: ts.ContinueStatement): StatementVisitResult;
    transformEmptyStatement(_statement: ts.EmptyStatement): StatementVisitResult;
    transformExpression(expression: ts.Expression): ExpressionVisitResult;
    protected transformBinaryOperation(left: tstl.Expression, right: tstl.Expression, operator: ts.BinaryOperator, tsOriginal: ts.Node): ExpressionVisitResult;
    protected transformTypeOfLiteralComparison(typeOfExpression: ts.TypeOfExpression, comparedExpression: tstl.StringLiteral, operator: ts.BinaryOperator, tsOriginal: ts.Node): ExpressionVisitResult;
    protected transformComparisonExpression(expression: ts.BinaryExpression): ExpressionVisitResult;
    transformBinaryExpression(expression: ts.BinaryExpression): ExpressionVisitResult;
    protected transformAssignment(lhs: ts.Expression, right: tstl.Expression, parent?: ts.Expression): tstl.Statement;
    protected transformAssignmentStatement(expression: ts.BinaryExpression): StatementVisitResult;
    protected transformFlattenableDestructuringAssignment(node: ts.DestructuringAssignment, right: tstl.Expression | tstl.Expression[]): tstl.Statement;
    protected transformDestructuringAssignment(node: ts.DestructuringAssignment, root: tstl.Expression): tstl.Statement[];
    protected transformObjectDestructuringAssignment(node: ts.ObjectDestructuringAssignment, root: tstl.Expression): tstl.Statement[];
    protected transformArrayDestructuringAssignment(node: ts.ArrayDestructuringAssignment, root: tstl.Expression): tstl.Statement[];
    protected transformShorthandPropertyAssignment(node: ts.ShorthandPropertyAssignment, root: tstl.Expression): tstl.Statement[];
    protected transformObjectLiteralAssignmentPattern(node: ts.ObjectLiteralExpression, root: tstl.Expression): tstl.Statement[];
    protected transformArrayLiteralAssignmentPattern(node: ts.ArrayLiteralExpression, root: tstl.Expression): tstl.Statement[];
    protected transformPropertyAssignment(node: ts.PropertyAssignment, root: tstl.Expression): tstl.Statement[];
    protected transformAssignmentExpression(expression: ts.BinaryExpression): tstl.CallExpression | tstl.MethodCallExpression;
    protected transformCompoundAssignmentExpression(expression: ts.Expression, lhs: ts.Expression, rhs: ts.Expression, replacementOperator: ts.BinaryOperator, isPostfix: boolean): tstl.CallExpression;
    transformBinaryOperator(operator: ts.BinaryOperator, node: ts.Node): tstl.BinaryOperator;
    transformClassExpression(expression: ts.ClassLikeDeclaration): ExpressionVisitResult;
    protected transformCompoundAssignmentStatement(node: ts.Node, lhs: ts.Expression, rhs: ts.Expression, replacementOperator: ts.BinaryOperator): tstl.Statement;
    protected transformUnaryBitLibOperation(node: ts.Node, expression: tstl.Expression, operator: tstl.UnaryBitwiseOperator, lib: string): ExpressionVisitResult;
    protected transformUnaryBitOperation(node: ts.Node, expression: tstl.Expression, operator: tstl.UnaryBitwiseOperator): ExpressionVisitResult;
    protected transformBinaryBitLibOperation(node: ts.Node, left: tstl.Expression, right: tstl.Expression, operator: ts.BinaryOperator, lib: string): ExpressionVisitResult;
    protected transformBinaryBitOperation(node: ts.Node, left: tstl.Expression, right: tstl.Expression, operator: ts.BinaryOperator): ExpressionVisitResult;
    protected transformProtectedConditionalExpression(expression: ts.ConditionalExpression): tstl.CallExpression;
    transformConditionalExpression(expression: ts.ConditionalExpression): ExpressionVisitResult;
    transformPostfixUnaryExpression(expression: ts.PostfixUnaryExpression): ExpressionVisitResult;
    transformPrefixUnaryExpression(expression: ts.PrefixUnaryExpression): ExpressionVisitResult;
    transformArrayLiteral(expression: ts.ArrayLiteralExpression): ExpressionVisitResult;
    transformObjectLiteral(expression: ts.ObjectLiteralExpression): ExpressionVisitResult;
    transformOmittedExpression(node: ts.OmittedExpression): ExpressionVisitResult;
    transformDeleteExpression(expression: ts.DeleteExpression): ExpressionVisitResult;
    transformFunctionExpression(node: ts.FunctionLikeDeclaration): ExpressionVisitResult;
    transformNewExpression(node: ts.NewExpression): ExpressionVisitResult;
    transformParenthesizedExpression(expression: ts.ParenthesizedExpression): ExpressionVisitResult;
    transformSuperKeyword(expression: ts.SuperExpression): ExpressionVisitResult;
    transformCallExpression(expression: ts.CallExpression): ExpressionVisitResult;
    protected transformGlobalFunctionCall(node: ts.CallExpression): tstl.Expression | undefined;
    transformPropertyCall(node: ts.CallExpression): ExpressionVisitResult;
    transformElementCall(node: ts.CallExpression): ExpressionVisitResult;
    transformContextualCallExpression(node: ts.CallExpression | ts.TaggedTemplateExpression, transformedArguments: tstl.Expression[]): ExpressionVisitResult;
    protected transformArguments<T extends ts.Expression>(params: ts.NodeArray<ts.Expression> | ts.Expression[], sig?: ts.Signature, context?: T): tstl.Expression[];
    transformPropertyAccessExpression(expression: ts.PropertyAccessExpression): ExpressionVisitResult;
    protected transformMathExpression(identifier: ts.Identifier): tstl.Expression;
    protected transformMathCallExpression(node: ts.CallExpression): tstl.Expression;
    protected transformStringProperty(node: ts.PropertyAccessExpression): tstl.UnaryExpression;
    protected transformArrayProperty(node: ts.PropertyAccessExpression): tstl.UnaryExpression | undefined;
    protected transformLuaTableProperty(node: ts.PropertyAccessExpression): tstl.UnaryExpression;
    protected transformElementAccessArgument(expression: ts.ElementAccessExpression): tstl.Expression;
    transformElementAccessExpression(expression: ts.ElementAccessExpression): ExpressionVisitResult;
    private tryGetConstEnumValue;
    protected transformStringCallExpression(node: ts.CallExpression): tstl.Expression;
    protected createStringCall(methodName: string, tsOriginal: ts.Node, ...params: tstl.Expression[]): tstl.CallExpression;
    protected transformStringExpression(identifier: ts.Identifier): ExpressionVisitResult;
    protected transformObjectCallExpression(expression: ts.CallExpression): ExpressionVisitResult;
    protected transformConsoleCallExpression(expression: ts.CallExpression): ExpressionVisitResult;
    protected isStringFormatTemplate(expression: ts.Expression): boolean;
    protected transformSymbolCallExpression(expression: ts.CallExpression): tstl.CallExpression;
    protected transformNumberCallExpression(expression: ts.CallExpression): tstl.CallExpression;
    protected validateLuaTableCall(expression: ts.CallExpression & {
        expression: ts.PropertyAccessExpression;
    }, isWithinExpressionStatement: boolean): void;
    protected transformLuaTableExpressionStatement(node: ts.ExpressionStatement & {
        expression: ts.CallExpression;
    } & {
        expression: {
            expression: ts.PropertyAccessExpression;
        };
    }): tstl.VariableDeclarationStatement | tstl.AssignmentStatement;
    protected transformLuaTableCallExpression(expression: ts.CallExpression & {
        expression: ts.PropertyAccessExpression;
    }): tstl.Expression;
    protected transformArrayCallExpression(node: ts.CallExpression): tstl.CallExpression;
    protected transformFunctionCallExpression(node: ts.CallExpression): tstl.CallExpression;
    transformArrayBindingElement(name: ts.ArrayBindingElement | ts.Expression): ExpressionVisitResult;
    transformAssertionExpression(expression: ts.AssertionExpression): ExpressionVisitResult;
    transformTypeOfExpression(expression: ts.TypeOfExpression): ExpressionVisitResult;
    transformSpreadElement(expression: ts.SpreadElement): ExpressionVisitResult;
    transformStringLiteral(literal: ts.StringLiteralLike): ExpressionVisitResult;
    transformNumericLiteral(literal: ts.NumericLiteral): ExpressionVisitResult;
    transformTrueKeyword(trueKeyword: ts.BooleanLiteral): ExpressionVisitResult;
    transformFalseKeyword(falseKeyword: ts.BooleanLiteral): ExpressionVisitResult;
    transformNullOrUndefinedKeyword(originalNode: ts.Node): ExpressionVisitResult;
    transformThisKeyword(thisKeyword: ts.ThisExpression): ExpressionVisitResult;
    transformTaggedTemplateExpression(expression: ts.TaggedTemplateExpression): ExpressionVisitResult;
    transformTemplateExpression(expression: ts.TemplateExpression): ExpressionVisitResult;
    transformPropertyName(propertyName: ts.PropertyName): ExpressionVisitResult;
    transformIdentifier(identifier: ts.Identifier): tstl.Identifier;
    protected transformIdentifierExpression(expression: ts.Identifier): tstl.Expression;
    protected getSymbolFromIdentifier(identifier: tstl.Identifier): ts.Symbol | undefined;
    protected getIdentifierExportScope(identifier: tstl.Identifier): ts.SourceFile | ts.ModuleDeclaration | undefined;
    protected isSymbolExported(symbol: ts.Symbol): boolean;
    protected isSymbolExportedFromScope(symbol: ts.Symbol, scope: ts.SourceFile | ts.ModuleDeclaration): boolean;
    protected addExportToIdentifier(identifier: tstl.Identifier): tstl.AssignmentLeftHandSideExpression;
    protected createExportedIdentifier(identifier: tstl.Identifier, exportScope?: ts.SourceFile | ts.ModuleDeclaration): tstl.AssignmentLeftHandSideExpression;
    protected createDefaultExportIdentifier(original: ts.Node): tstl.Identifier;
    protected createDefaultExportStringLiteral(original: ts.Node): tstl.StringLiteral;
    protected getSymbolExportScope(symbol: ts.Symbol): ts.SourceFile | ts.ModuleDeclaration | undefined;
    protected transformLuaLibFunction(func: LuaLibFeature, tsParent?: ts.Expression, ...params: tstl.Expression[]): tstl.CallExpression;
    protected checkForLuaLibType(type: ts.Type): void;
    protected importLuaLibFeature(feature: LuaLibFeature): void;
    protected createImmediatelyInvokedFunctionExpression(statements: tstl.Statement[], result: tstl.Expression | tstl.Expression[], tsOriginal?: ts.Node): tstl.CallExpression;
    protected createUnpackCall(expression: tstl.Expression | undefined, tsOriginal?: ts.Node): tstl.Expression;
    protected createSelfIdentifier(tsOriginal?: ts.Node): tstl.Identifier;
    protected createExportsIdentifier(): tstl.Identifier;
    protected createLocalOrExportedOrGlobalDeclaration(lhs: tstl.Identifier | tstl.Identifier[], rhs?: tstl.Expression | tstl.Expression[], tsOriginal?: ts.Node, parent?: tstl.Node, overrideExportScope?: ts.SourceFile | ts.ModuleDeclaration): tstl.Statement[];
    protected validateFunctionAssignment(node: ts.Node, fromType: ts.Type, toType: ts.Type, toName?: string): void;
    protected validatePropertyAssignment(node: ts.Node): void;
    protected wrapInFunctionCall(expression: tstl.Expression): tstl.FunctionExpression;
    protected wrapInTable(...expressions: tstl.Expression[]): tstl.ParenthesizedExpression;
    protected wrapInToStringForConcat(expression: tstl.Expression): tstl.Expression;
    protected expressionPlusOne(expression: tstl.Expression): tstl.Expression;
    protected createShorthandIdentifier(valueSymbol: ts.Symbol | undefined, propertyIdentifier: ts.Identifier): tstl.Expression;
    protected isUnsafeName(name: string): boolean;
    protected hasUnsafeSymbolName(symbol: ts.Symbol, tsOriginal?: ts.Identifier): boolean;
    protected hasUnsafeIdentifierName(identifier: ts.Identifier): boolean;
    protected createSafeName(name: string): string;
    protected trackSymbolReference(symbol: ts.Symbol, identifier: ts.Identifier): tstl.SymbolId | undefined;
    protected getIdentifierSymbolId(identifier: ts.Identifier): tstl.SymbolId | undefined;
    protected findScope(scopeTypes: ScopeType): Scope | undefined;
    protected peekScope(): Scope | undefined;
    protected pushScope(scopeType: ScopeType): void;
    protected shouldHoist(symbolId: tstl.SymbolId, scope: Scope): boolean;
    protected replaceStatementInParent(oldNode: tstl.Statement, newNode?: tstl.Statement): void;
    protected hoistImportStatements(scope: Scope, statements: tstl.Statement[]): tstl.Statement[];
    protected hoistFunctionDefinitions(scope: Scope, statements: tstl.Statement[]): tstl.Statement[];
    protected hoistVariableDeclarations(scope: Scope, statements: tstl.Statement[]): tstl.Statement[];
    protected performHoisting(statements: tstl.Statement[]): tstl.Statement[];
    protected popScope(): Scope;
    protected createHoistableVariableDeclarationStatement(identifier: tstl.Identifier, initializer?: tstl.Expression, tsOriginal?: ts.Node, parent?: tstl.Node): tstl.AssignmentStatement | tstl.VariableDeclarationStatement;
    protected statementVisitResultToArray(visitResult: StatementVisitResult): tstl.Statement[];
    protected filterUndefined<T>(items: Array<T | undefined>): T[];
    protected filterUndefinedAndCast<TOriginal, TCast extends TOriginal>(items: Array<TOriginal | undefined>, cast: (item: TOriginal) => item is TCast): TCast[];
    protected createConstructorDecorationStatement(declaration: ts.ClassLikeDeclaration): tstl.AssignmentStatement | undefined;
}
export {};
