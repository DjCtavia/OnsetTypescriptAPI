import * as ts from "typescript";
import { Decorator, DecoratorKind } from "./Decorator";
import * as tstl from "./LuaAST";
import { EmitResolver } from "./LuaTransformer";
export declare enum ContextType {
    None = 0,
    Void = 1,
    NonVoid = 2,
    Mixed = 3
}
export declare function getExtendedTypeNode(node: ts.ClassLikeDeclarationBase, checker: ts.TypeChecker): ts.ExpressionWithTypeArguments | undefined;
export declare function getExtendedType(node: ts.ClassLikeDeclarationBase, checker: ts.TypeChecker): ts.Type | undefined;
export declare function isAssignmentPattern(node: ts.Node): node is ts.AssignmentPattern;
export declare function getExportable(exportSpecifiers: ts.NamedExports, resolver: EmitResolver): ts.ExportSpecifier[];
export declare function isDefaultExportSpecifier(node: ts.ExportSpecifier): boolean;
export declare function hasDefaultExportModifier(modifiers?: ts.NodeArray<ts.Modifier>): boolean;
export declare function shouldResolveModulePath(moduleSpecifier: ts.Expression, checker: ts.TypeChecker): boolean;
export declare function shouldBeImported(importNode: ts.ImportClause | ts.ImportSpecifier, checker: ts.TypeChecker, resolver: EmitResolver): boolean;
export declare function isFileModule(sourceFile: ts.SourceFile): boolean;
export declare function isStatementExported(statement: ts.Statement): boolean;
export declare function getExportedSymbolDeclaration(symbol: ts.Symbol): ts.Declaration | undefined;
export declare function isDeclaration(node: ts.Node): node is ts.Declaration;
export declare function isInDestructingAssignment(node: ts.Node): boolean;
export declare function forTypeOrAnySupertype(type: ts.Type, checker: ts.TypeChecker, predicate: (type: ts.Type) => boolean): boolean;
export declare function isAmbientNode(node: ts.Declaration): boolean;
export declare function isStaticNode(node: ts.Node): boolean;
export declare function isTypeWithFlags(type: ts.Type, flags: ts.TypeFlags, checker: ts.TypeChecker, program: ts.Program): boolean;
export declare function isStringType(type: ts.Type, checker: ts.TypeChecker, program: ts.Program): boolean;
export declare function isNumberType(type: ts.Type, checker: ts.TypeChecker, program: ts.Program): boolean;
export declare function isExplicitArrayType(type: ts.Type, checker: ts.TypeChecker, program: ts.Program): boolean;
export declare function isFunctionType(type: ts.Type, checker: ts.TypeChecker): boolean;
export declare function isFunctionTypeAtLocation(node: ts.Node, checker: ts.TypeChecker): boolean;
export declare function isArrayType(type: ts.Type, checker: ts.TypeChecker, program: ts.Program): boolean;
export declare function isLuaIteratorType(node: ts.Node, checker: ts.TypeChecker): boolean;
export declare function isRestParameter(node: ts.Node, checker: ts.TypeChecker): boolean;
export declare function isVarArgType(node: ts.Node, checker: ts.TypeChecker): boolean;
export declare function isForRangeType(node: ts.Node, checker: ts.TypeChecker): boolean;
export declare function isTupleReturnCall(node: ts.Node, checker: ts.TypeChecker): boolean;
export declare function isInTupleReturnFunction(node: ts.Node, checker: ts.TypeChecker): boolean;
export declare function getContainingFunctionReturnType(node: ts.Node, checker: ts.TypeChecker): ts.Type | undefined;
export declare function collectCustomDecorators(source: ts.Symbol | ts.Signature, checker: ts.TypeChecker, decMap: Map<DecoratorKind, Decorator>): void;
export declare function getCustomDecorators(type: ts.Type, checker: ts.TypeChecker): Map<DecoratorKind, Decorator>;
export declare function getCustomNodeDirectives(node: ts.Node): Map<DecoratorKind, Decorator>;
export declare function getCustomFileDirectives(file: ts.SourceFile): Map<DecoratorKind, Decorator>;
export declare function getCustomSignatureDirectives(signature: ts.Signature, checker: ts.TypeChecker): Map<DecoratorKind, Decorator>;
export declare function findFirstNodeAbove<T extends ts.Node>(node: ts.Node, callback: (n: ts.Node) => n is T): T | undefined;
export declare function isBinaryAssignmentToken(token: ts.SyntaxKind): [true, ts.BinaryOperator] | [false, undefined];
export declare function isExpressionWithEvaluationEffect(node: ts.Expression): boolean;
export declare function isAccessExpressionWithEvaluationEffects(node: ts.Expression, checker: ts.TypeChecker, program: ts.Program): [true, ts.Expression, ts.Expression] | [false, undefined, undefined];
export declare function isDefaultArrayCallMethodName(methodName: string): boolean;
export declare function getExplicitThisParameter(signatureDeclaration: ts.SignatureDeclaration): ts.ParameterDeclaration | undefined;
export declare function findInClassOrAncestor(classDeclaration: ts.ClassLikeDeclarationBase, callback: (classDeclaration: ts.ClassLikeDeclarationBase) => boolean, checker: ts.TypeChecker): ts.ClassLikeDeclarationBase | undefined;
export declare function hasSetAccessorInClassOrAncestor(classDeclaration: ts.ClassLikeDeclarationBase, isStatic: boolean, checker: ts.TypeChecker): boolean;
export declare function hasGetAccessorInClassOrAncestor(classDeclaration: ts.ClassLikeDeclarationBase, isStatic: boolean, checker: ts.TypeChecker): boolean;
export declare function getPropertyName(propertyName: ts.PropertyName): string | number | undefined;
export declare function isSamePropertyName(a: ts.PropertyName, b: ts.PropertyName): boolean;
export declare function isGetAccessorOverride(element: ts.ClassElement, classDeclaration: ts.ClassLikeDeclarationBase, checker: ts.TypeChecker): element is ts.GetAccessorDeclaration;
export declare function inferAssignedType(expression: ts.Expression, checker: ts.TypeChecker): ts.Type;
export declare function getAllCallSignatures(type: ts.Type): ReadonlyArray<ts.Signature>;
export declare function getSignatureDeclarations(signatures: readonly ts.Signature[], checker: ts.TypeChecker): ts.SignatureDeclaration[];
export declare function hasNoSelfAncestor(declaration: ts.Declaration, checker: ts.TypeChecker): boolean;
export declare function getDeclarationContextType(signatureDeclaration: ts.SignatureDeclaration, checker: ts.TypeChecker): ContextType;
export declare function reduceContextTypes(contexts: ContextType[]): ContextType;
export declare function getFunctionContextType(type: ts.Type, checker: ts.TypeChecker): ContextType;
export declare function escapeString(text: string): string;
export declare function isValidLuaIdentifier(str: string): boolean;
export declare function fixInvalidLuaIdentifier(name: string): string;
export declare function isValidLuaFunctionDeclarationName(str: string): boolean;
export declare function isFalsible(type: ts.Type, strictNullChecks: boolean): boolean;
export declare function getFirstDeclaration(symbol: ts.Symbol, sourceFile: ts.SourceFile): ts.Declaration | undefined;
export declare function getRawLiteral(node: ts.LiteralLikeNode): string;
export declare function isFirstDeclaration(node: ts.VariableDeclaration, checker: ts.TypeChecker, sourceFile: ts.SourceFile): boolean;
export declare function isStandardLibraryDeclaration(declaration: ts.Declaration, program: ts.Program): boolean;
export declare function isStandardLibraryType(type: ts.Type, name: string | undefined, program: ts.Program): boolean;
export declare function isEnumMember(enumDeclaration: ts.EnumDeclaration, value: ts.Expression): [true, ts.PropertyName] | [false, undefined];
export declare function isWithinLiteralAssignmentStatement(node: ts.Node): boolean;
export declare function moduleHasEmittedBody(statement: ts.ModuleDeclaration): statement is ts.ModuleDeclaration & {
    body: ts.ModuleBlock | ts.ModuleDeclaration;
};
export declare function isValidFlattenableDestructuringAssignmentLeftHandSide(node: ts.DestructuringAssignment, checker: ts.TypeChecker, program: ts.Program): boolean;
export declare function isArrayLength(expression: ts.Expression, checker: ts.TypeChecker, program: ts.Program): expression is ts.PropertyAccessExpression | ts.ElementAccessExpression;
export declare function isSimpleExpression(expression: tstl.Expression): boolean;
export declare function getAbsoluteImportPath(relativePath: string, directoryPath: string, options: ts.CompilerOptions): string;
export declare function getImportPath(fileName: string, relativePath: string, node: ts.Node, options: ts.CompilerOptions): string;
export declare function getExportPath(fileName: string, options: ts.CompilerOptions): string;
export declare function formatPathToLuaPath(filePath: string): string;
