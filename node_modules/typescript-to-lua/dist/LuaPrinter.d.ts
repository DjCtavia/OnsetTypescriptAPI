import { SourceNode } from "source-map";
import { CompilerOptions } from "./CompilerOptions";
import * as tstl from "./LuaAST";
import { LuaLibFeature } from "./LuaLib";
import { EmitHost } from "./Transpile";
declare type SourceChunk = string | SourceNode;
export declare class LuaPrinter {
    private options;
    private emitHost;
    private static operatorMap;
    private currentIndent;
    private sourceFile;
    constructor(options: CompilerOptions, emitHost: EmitHost);
    print(block: tstl.Block, luaLibFeatures?: Set<LuaLibFeature>, sourceFile?: string): [string, string];
    private printInlineSourceMap;
    private printStackTraceOverride;
    private printImplementation;
    protected pushIndent(): void;
    protected popIndent(): void;
    protected indent(input?: SourceChunk): SourceChunk;
    protected createSourceNode(node: tstl.Node, chunks: SourceChunk | SourceChunk[], name?: string): SourceNode;
    protected concatNodes(...chunks: SourceChunk[]): SourceNode;
    protected printBlock(block: tstl.Block): SourceNode;
    private statementMayRequireSemiColon;
    private nodeStartsWithParenthesis;
    protected printStatementArray(statements: tstl.Statement[]): SourceChunk[];
    printStatement(statement: tstl.Statement): SourceNode;
    printDoStatement(statement: tstl.DoStatement): SourceNode;
    printVariableDeclarationStatement(statement: tstl.VariableDeclarationStatement): SourceNode;
    printVariableAssignmentStatement(statement: tstl.AssignmentStatement): SourceNode;
    printIfStatement(statement: tstl.IfStatement): SourceNode;
    printWhileStatement(statement: tstl.WhileStatement): SourceNode;
    printRepeatStatement(statement: tstl.RepeatStatement): SourceNode;
    printForStatement(statement: tstl.ForStatement): SourceNode;
    printForInStatement(statement: tstl.ForInStatement): SourceNode;
    printGotoStatement(statement: tstl.GotoStatement): SourceNode;
    printLabelStatement(statement: tstl.LabelStatement): SourceNode;
    printReturnStatement(statement: tstl.ReturnStatement): SourceNode;
    printBreakStatement(statement: tstl.BreakStatement): SourceNode;
    printExpressionStatement(statement: tstl.ExpressionStatement): SourceNode;
    printExpression(expression: tstl.Expression): SourceNode;
    printStringLiteral(expression: tstl.StringLiteral): SourceNode;
    printNumericLiteral(expression: tstl.NumericLiteral): SourceNode;
    printNilLiteral(expression: tstl.NilLiteral): SourceNode;
    printDotsLiteral(expression: tstl.DotsLiteral): SourceNode;
    printBooleanLiteral(expression: tstl.BooleanLiteral): SourceNode;
    private printFunctionParameters;
    printFunctionExpression(expression: tstl.FunctionExpression): SourceNode;
    printFunctionDefinition(statement: tstl.FunctionDefinition): SourceNode;
    printTableFieldExpression(expression: tstl.TableFieldExpression): SourceNode;
    printTableExpression(expression: tstl.TableExpression): SourceNode;
    printUnaryExpression(expression: tstl.UnaryExpression): SourceNode;
    printBinaryExpression(expression: tstl.BinaryExpression): SourceNode;
    private canStripParenthesis;
    printParenthesizedExpression(expression: tstl.ParenthesizedExpression): SourceNode;
    printCallExpression(expression: tstl.CallExpression): SourceNode;
    printMethodCallExpression(expression: tstl.MethodCallExpression): SourceNode;
    printIdentifier(expression: tstl.Identifier): SourceNode;
    printTableIndexExpression(expression: tstl.TableIndexExpression): SourceNode;
    printOperator(kind: tstl.Operator): SourceNode;
    protected removeDeadAndEmptyStatements(statements: tstl.Statement[]): tstl.Statement[];
    protected isStatementEmpty(statement: tstl.Statement): boolean;
    protected joinChunks(separator: string, chunks: SourceChunk[]): SourceChunk[];
    protected printExpressionList(expressions: tstl.Expression[]): SourceChunk[];
    private buildSourceMap;
}
export {};
